1.  Назовите основные принципы ООП. Расскажите подробно о каждом
    
Инкапсуляция
Инкапсуляция — это механизм, который позволяет скрывать внутренние детали объекта и предоставлять доступ к ним 
только через определенные методы. Это помогает защитить данные от некорректного использования и упрощает изменение 
внутренней реализации объекта без необходимости изменения кода, который его использует. Инкапсуляция способствует 
созданию более безопасного и устойчивого к ошибкам кода, так как разработчики могут контролировать доступ к данным
и методы их изменения.

Наследование
Наследование позволяет создавать новые классы на основе уже существующих. Это позволяет повторно использовать код и 
упрощает создание иерархий классов. В Java наследование достигается с помощью ключевого слова extends. Наследование 
способствует созданию более организованного и структурированного кода, так как позволяет группировать общие свойства и 
методы в базовом классе и переопределять их в подклассах.

Полиморфизм
Полиморфизм позволяет объектам разных классов обрабатывать данные по-разному, но через единый интерфейс. Это достигается 
через переопределение методов в подклассах. Полиморфизм делает код более гибким и расширяемым, так как позволяет 
использовать один и тот же метод для объектов разных классов, которые реализуют этот метод по-своему.

Абстракция
Абстракция позволяет скрывать сложные детали реализации и предоставлять простой интерфейс для взаимодействия с объектом. 
Это достигается через использование абстрактных классов и интерфейсов, которые определяют общие методы и свойства для 
группы объектов. Абстракция способствует созданию более понятного и легко поддерживаемого кода, так как позволяет 
сосредоточиться на высокоуровневых концепциях и скрывать детали реализации.

Источник: https://github.com/Shell26/Java-Developer/blob/master/oop.md#%D0%9D%D0%B0%D0%B7%D0%BE%D0%B2%D0%B8%D1%82%D0%B5-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%9E%D0%9E%D0%9F

2.  Расскажите про иерархию наследования. Подробно про методы класса
    object.
    
    Иерархия наследования в Java
    Класс Object:
    Это корневой класс для всех классов в Java.
    Все классы наследуют методы класса Object, даже если они не указаны явно.
    Пользовательские классы:
    Если класс не наследует явно другой класс, он автоматически наследует Object.
    Если класс наследует другой класс, он также косвенно наследует Object.
    Методы класса Object
    Класс Object содержит несколько важных методов, которые доступны всем классам в Java.
    Эти методы можно переопределять в пользовательских классах для изменения их поведения.
    toString()
    •	Возвращает строковое представление объекта.
    •	По умолчанию возвращает строку
    equals(Object obj)
    •	Сравнивает текущий объект с другим объектом на равенство.
    •	По умолчанию сравнивает ссылки на объекты (т.е. this == obj).
    •	Переопределение:
    hashCode()
    •	Возвращает целочисленный хэш-код объекта.
    •	Используется в коллекциях, таких как HashMap и HashSet.
    •	По умолчанию возвращает адрес объекта в памяти.
    •	Переопределение:
    getClass()
    •	Возвращает объект класса Class, который представляет класс текущего объекта.
    •	Не может быть переопределен.
    •	Пример:
    clone()
    •	Создает и возвращает копию объекта.
    •	Класс должен реализовать интерфейс Cloneable, иначе будет выброшено исключение CloneNotSupportedException
    finalize()
    •	Вызывается сборщиком мусора перед удалением объекта.
    •	Не рекомендуется использовать, так как поведение непредсказуемо.
    •	Переопределение:
    wait(), notify(), notifyAll()
    •	Используются для управления потоками (синхронизация).
    •	wait(): Приостанавливает текущий поток до тех пор, пока другой поток не вызовет notify() или notifyAll().
    •	notify(): Пробуждает один поток, ожидающий на мониторе объекта.
    •	notifyAll(): Пробуждает все потоки, ожидающие на мониторе объекта.

3.  Что такое интерфейс, что такое абстрактный класс.
Интерфейс — это контракт, который реализуется в некотором классе. У интерфейса не может быть состояния, поэтому в нем нельзя использовать изменяемые поля экземпляра. В интерфейсе могут быть только неизменяемые final-поля (константы).

Абстрактный класс похож на обычный, но отличается тем, что может содержать абстрактные методы — методы без реализации, и нельзя создать экземпляр абстрактного класса.
Если ряд ваших классов содержит одинаковые методы, но с разными реализациями, то стоит использовать интерфейс. Абстрактный класс лучше использовать, когда вам нужно изменяемое состояние. Если хранить состояние класса не нужно, обычно лучше использовать интерфейс.

4.  Может ли интерфейс \\ абстрактный класс иметь конструктор, поля, статические статические \\ дефолтные методы.
5.  Что такое Enum , в чем отличие от класса, может ли иметь методы , конструкторы , наследоваться реализовывать интерфейсы.
    ENUM (перечисление) в Java — это специальный тип, который используется для определения набора констант. 
Он может быть сравнен с классом, но имеет некоторые отличия и особенности.
    ENUM используется для создания перечислений, которые представляют фиксированный набор значений. 
Например, дни недели, месяцы, направления и т. д.

    Отличия от класса:

Неподвижность: 
Элементы перечисления не могут быть изменены. Это означает, что вы не можете создать новый элемент перечисления в 
момент выполнения программы.

Финализированные: 
Перечисления не могут быть расширены, т.е. вы не можете наследовать от enum. Все перечисления являются по умолчанию final.

Предопределенные экземпляры: 
Каждый элемент перечисления является экземпляром того самого enum типа, и они объявлены заранее.

Методы:
enum может содержать методы. Вы можете определять свои собственные методы и переопределять стандартные методы класса Object.

ENUM может иметь конструкторы, но они должны быть приватными. Это ограничено выбором значений, которые можно создавать, 
и каждый элемент перечисления является единственным значением.

ENUM может реализовывать интерфейсы, как и обычные классы.
6.  Расскажите про модификаторы доступа, к чему они применяются.

	Модификаторы доступа в Java используются для управления видимостью и доступностью классов, методов, полей и конструкторов. Они определяют, какие части кода могут быть доступны из других классов или пакетов. В Java существует четыре основных модификатора доступа:
	- public: Применяется к классам, методам, полям и конструкторам.Элемент, помеченный как public, доступен из любого другого класса и пакета.
	- protected: Применяется к методам, полям и конструкторам (не может быть применен к классам, за исключением вложенных классов).Элемент, помеченный как protected, доступен внутри того же пакета, а также в подклассах, даже если они находятся в других пакетах.
	- default (package-private): Если модификатор доступа не указан, используется доступ по умолчанию (package-private).Элемент доступен только внутри того же пакета.
	- private: Применяется к методам, полям и конструкторам (не может быть применен к классам, за исключением вложенных классов). Элемент, помеченный как private, доступен только внутри того же класса.
	
	Применение модификаторов доступа:
	Классы: Могут быть public или default (package-private). Класс с модификатором public может быть доступен из любого пакета, а класс с доступом по умолчанию — только внутри своего пакета.
	Методы и поля: Могут быть public, protected, default или private. Выбор модификатора зависит от того, насколько широко должен быть доступен элемент.
	Конструкторы: Могут быть public, protected, default или private. Например, private конструктор используется для реализации паттерна Singleton.

	Использование модификаторов доступа помогает обеспечить инкапсуляцию и контролировать взаимодействие между различными частями программы.

7.  Расскажите про конструкторы, с какими модификаторами они
    применяются, могут ли они наследоваться \\ переопреляться ?
    Конструкторы и инициализаторы не наследуются подклассами в Java.

Конструкторы - это специальные методы класса, которые вызываются при создании нового объекта класса. 
Конструкторы не наследуются, поскольку они не являются членами класса, а скорее служат для его инициализации. 
Подкласс может вызывать конструкторы суперкласса, используя ключевое слово super, но он не наследует их.

Инициализатор - это блоки кода, которые выполняются при создании объектов класса или при загрузке класса. В
Java есть два типа инициализаторов: статические и нестатические.

Статические инициализаторы выполняются только один раз при загрузке класса, а нестатические инициализаторы выполняются 
каждый раз при создании нового объекта. Инициализаторы также не наследуются подклассами, поскольку они не относятся 
непосредственно к объектам класса, а скорее к его определению.

Однако, если суперкласс содержит конструкторы или инициализаторы с модификатором доступа protected или public, 
то они будут доступны подклассам и могут быть вызваны из них при помощи ключевого слова super.

8.  Можно ли в классе заимплементить 2 интерфейса? А если в них один и
    тот же метод doSmth? Как он реализуется?
9.  Статический \\ динамический полиморфизм.
При статическом варианте развития событий метод можно вызывать при компиляции кода, происходит это при помощи рассмотренной нами ранее концепции — перегрузки методов.
   Говоря проще, у них будет одинаковое название, но разная функциональная начинка (тип возвращаемых данных, свойств и т. д.).
   В таком случае Java позволяет пользователю свободно определять функциям идентичные названия, если они будут отличны по типу и параметрам.

   При динамическом полиморфизме вызвать переопределеный метод можно при выполнении программы.
   Скопировать метод родительского класса и обозначить его в дочернем можно с помощью ссылочной переменной родительского класса,
   при этом вызванный метод будет определяться по объекту, на который она ссылается. Такую операцию еще называют Upcasting/

10. Что является членами класса.
    Членами класса являются унаследованные компоненты тела класса, включая поля, методы, вложенные классы, 
интерфейсы и перечислимые типы. Конструкторы не относятся к членам класса.

    https://docs.oracle.com/javase/tutorial/reflect/member/index.html
11. Расскажите подробно как переопределяются\\ перегружаются методы
    классов наследников.
1 Переопределение метода (Overriding)
    Переопределение метода происходит, когда класс-наследник предоставляет свою реализацию метода, который был уже объявлен в его родительском классе. Это позволяет изменить поведение унаследованного метода в классе-наследнике.

    *Правила переопределения:*
    * Метод в дочернем классе должен иметь тот же тип возвращаемого значения (или его подкласс).
    * Метод должен сохранить такую же сигнатуру, то есть:
        * Тот же имя метода.
        * Тот же список параметров (тип и количество).
    * Модификатор доступа метода в классе-наследнике должен быть не менее строгим, чем в родительском классе.
      Например, если метод родительского класса был protected, в дочернем классе он может быть protected или public, но не private.
    * Метод, который переопределяется, не может быть final, static или private в родительском классе (так как они не могут быть переопределены).
        Аннотация @Override
      
    Использование аннотации @Override является хорошей практикой, так как она помогает компилятору проверить,
    что метод действительно переопределяет родительский метод. Если ты случайно напишешь неправильную сигнатуру
    (например, изменишь имя метода или параметры), компилятор выдаст ошибку.


2 Перегрузка метода (Overloading)
    Перегрузка метода происходит, когда в одном классе объявляется несколько методов с одинаковым именем,
    но с разными параметрами (по количеству или типу параметров). Перегрузка позволяет использовать одно имя метода для
    выполнения схожих операций, но с разными     типами данных или количеством аргументов.
    
Правила перегрузки:
    * Перегруженные методы должны иметь одинаковое имя.
    * Методы должны иметь разный список параметров: различия могут быть в количестве параметров, типах параметров или их
    порядке.
    * Перегрузка не зависит от типа возвращаемого значения, так как компилятор Java использует только параметры для выбора
    метода, а не возвращаемое значение.

Переопределение используется для изменения поведения метода, унаследованного от родительского класса,
    и важно для работы с полиморфизмом.
    Перегрузка позволяет создавать несколько методов с одним именем, но разными параметрами,
    что помогает улучшить читаемость и удобство работы с кодом.
    [самая полезная ссылка](https://chatgpt.com)

12. Jvm, Jre, Jdk

    JVM, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE). 
Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. 
JVM может также использоваться для выполнения программ, написанных на других языках программирования.

    JRE, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины 
для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.

    JDK, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, 
включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.

    Коротко: JDK - среда для разработки программ на Java, включающая в себя JRE - среду для обеспечения запуска Java программ, 
которая в свою очередь содержит JVM - интерпретатор кода Java программ.

    https://github.com/Shell26/Java-Developer/blob/master/core.md#%D0%A7%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B0%D1%8E%D1%82%D1%81%D1%8F-jre-jvm-%D0%B8-jdk

13. Расскажите что такое classpath java, общее правило именования
    пакетов java

    Путь к классам сообщает инструментам и приложениям JDK, где найти сторонние и пользовательские классы, то есть классы,
    которые не являются расширениями Java или частью платформы Java. Путь к классам должен найти все классы, которые вы 
    скомпилировали с помощью компилятора javac, — по умолчанию это текущий каталог, чтобы было удобно находить эти классы. 
    Путь поиска класса можно задать с помощью параметра –classpath при вызове инструмента JDK или путем установки CLASSPATH 
    переменной среды. –classpath параметр предпочтительнее, поскольку его можно задать индивидуально для каждого приложения.
    C:> sdkTool -classpath classpath1;classpath2...
    -или-
    C:> set CLASSPATH=classpath1 ;classpath2 ...
    sdkTool - Инструмент командной строки, например java, javac, javadoc, или apt.
    https://docs.oracle.com/javase/7/docs/technotes/tools/windows/classpath.html

    Имена пакетов пишутся строчными буквами, чтобы избежать конфликта с именами классов или интерфейсов.
    Компании используют свое перевернутое доменное имя в Интернете в качестве начала имен своих пакетов, например, 
    com.example.mypackage для пакета mypackage, созданного программистом в example.com.
    Конфликты имен, возникающие в пределах одной компании, необходимо разрешать с помощью соглашений внутри этой компании, 
    возможно, путем включения названия региона или проекта после названия компании (например, com.example.region.mypackage).
    Пакеты в самом языке Java начинаются с java. или javax.
    В некоторых случаях имя интернет-домена может не быть допустимым именем пакета. Это может произойти, если имя домена 
    содержит дефис или другой специальный символ, если имя пакета начинается с цифры или другого символа, который запрещено 
    использовать в качестве начала имени Java, или если имя пакета содержит зарезервированное ключевое слово Java, например 
    "int". В этом случае предлагается добавить подчеркивание:
    example.int –> int_.example
    hyphenated-name.example.org -> org.example.hyphenated_name
    123name.example.com -> com.example._123name
    https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html

    https://docs.oracle.com/javase/8/docs/api/java/lang/String.html
14. Расскажите про интерфейсы Comparator, Comparable и их применение.
    Comparable — это интерфейс, используемый для сортировки классов на основе их естественного порядка. Интерфейс Comparable должен быть реализован в классе, который будет использоваться для сортировки. Этот класс можно сортировать на основе отдельных атрибутов, таких как идентификатор, имя, отдел и так далее.
    Класс, реализующий интерфейс Comparable, сравнивает себя с другими объектами. Реализованный класс предлагает пользовательскую реализацию int CompareTo(T var1) для пользовательской сортировки.

    Метод int CompareTo(T var1) должен быть переопределен таким образом, чтобы:
    1) Он должен возвращать целое положительное значение Positive(+ve), если этот объект больше объекта сравнения.
    2) Он должен возвращать целое отрицательное значение Negative(-ve), если этот объект меньше объекта сравнения.
    3) Он должен вернуть Zero(0), если этот и сравниваемый объект равны.
       При использовании класса Comparable можно сортировать только по одному атрибуту.

       public class Student  implements Comparable<Student>{
       private Integer id;
       private String name;
       private String department;

       @Override
       public int compareTo(Student student) {
       return this.name.compareTo(student.name);
       }
       }

    Comparator — это интерфейс, который также используется для сортировки коллекций в Java. В отличие от Comparable, интерфейс Comparator не обязательно должен быть реализован в исходном классе, его можно реализовать и в отдельном классе.
    Используя Comparator, мы можем сортировать список на основе различных атрибутов в соответствии с нашими требованиями. В компараторе два объекта передаются в метод сравнения и сравниваются друг с другом. Метод int Compare(T var1, T var2) должен быть реализован пользовательским классом компаратора.

    Метод int Compare(T var1, T var2) должен быть переопределен таким образом, чтобы:
    1) Он должен возвращать целое число положительное значение Positive(+ve), если первый объект больше второго объекта.
    2) Он должен возвращать целое отрицательное значение Negative(-ve), если первый объект меньше второго объекта.
    3) Он должен возвращать Zero(0), если оба объекта равны.

       class StudentDeptComparator implements Comparator<Student> {

    @Override
    public int compare(Student s1, Student s2) {
    return s1.getDepartment().compareTo(s2.getDepartment());
    }
    }
    https://javarush.com/groups/posts/6459-kofe-breyk-253-v-chem-razlichie-mezhdu-comparable-i-comparator-chto-takoe-varargs-peremennihe-a

15. Расскажите про класс String, пул строк - String это final класс объекты которого представляют собой строки(последовательность
    символов). Строки это неизменяемые объекты, это значит что при
    конкатенации или получении подстроки возвращается новый объект.
    StringPool - это область в Heap где хранятся строки. При создании
    строки с помощью \"\" проверяется есть ли такая строка в StringPool
    и если она там есть то возвращается ссылка на нее. Это помогает
    экономить память. При создании новой строки с помощью new будет
    создан новый объект, можно поместить строку в пул или же получить
    ссылку на другой объект с таким же значением из пулла с помощью
    метода intern().
    https://docs.oracle.com/javase/8/docs/api/java/lang/String.html
16. Расскажите про варианты использования зарезервированных слов таких
    как super, this, class, instace of

17. java массивы, к какому типу относится, какие есть особенности можно ли создать 0 длинны, могут ли расширяться.
    Тип массива:
    Массив является ссылочным типом:
    Особенности массивов:
    Размер массива фиксирован:
    После создания массива его длина (количество элементов) не может быть изменена.
    Например, массив длины 5 останется длиной 5, даже если все его элементы установлены в null или эквивалентное значение.
    Доступ через индекс:
    Индексация начинается с 0. Попытка обратиться к элементу за пределами диапазона (например, array[-1] или array[array.length]) вызовет исключение ArrayIndexOutOfBoundsException.
    Инициализация по умолчанию:
    Если массив создаётся, но его элементы не инициализируются явно, они принимают значения по умолчанию:
    Примитивные типы (int, double и т.д.) → 0, 0.0.
    Логический тип (boolean) → false.
    Ссылочные типы → null.
    Многомерные массивы:
    Можно ли создать массив длиной 0?
    Да, массив длиной 0 создать можно:
    Пример: int[] emptyArray = new int[0];.
    Такой массив существует, но в нём нет элементов, и любая попытка обратиться к элементу вызовет ArrayIndexOutOfBoundsException.
    Могут ли массивы расширяться?
    Нет, массивы в Java не могут расширяться:
    Размер массива фиксирован после его создания.

18. Назовите этапы создания \\запуска блоков\\конструкторов класса при
    наследовании.
    Сначала один раз загружаются и выполняются статические блоки и поля в порядке их объявления внутри классов.
    Первыми выполняются все блоки и поля родительского класса, затем каждого из дочерних, в порядке иерархии.
    Статические поля и блоки выполняются только один раз при первом взаимодействии с классом. Затем выполняются нестатические поля,
    блоки и конструкторы родительского класса. При чем поля и блоки в порядке их объявления, а конструктор всегда в конце.
    После завершения реализации родительского класса, выполнение переходит к дочерним, в порядке иерархии.
    Сначала один раз загружаются и выполняются статические блоки и поля в порядке их объявления внутри классов.
    Первыми выполняются все блоки и поля родительского класса, затем каждого из дочерних, в порядке иерархии. Статические поля и
    блоки выполняются только один раз при первом взаимодействии с классом. Затем выполняются нестатические поля, блоки и конструкторы
    родительского класса. При чем поля и блоки в порядке их объявления,
    а конструктор всегда в конце. После завершения реализации родительского класса, выполнение переходит к дочерним, в порядке иерархии.
19. Расскажите какое будет поведение если внутри цикла вызвать оператор
    break\\continue.
Оператор break
   При выполнении оператора break внутри цикла происходит немедленный выход из текущего цикла, независимо от того, выполнены ли все оставшиеся итерации.
   Управление передаётся на первую инструкцию, расположенную за пределами этого цикла.
   Используется для прекращения выполнения цикла, если выполнение дальнейших итераций становится бессмысленным или нежелательным.
   Пример:
   `for (let i = 0; i < 10; i++) {
if (i === 5) {
break; // Цикл завершится, как только i станет равно 5
}
console.log(i);
}`
   console.log("Цикл завершён.");
   Результат:
   0
   1
   2
   3
   4
   Цикл завершён. 
Оператор continue
   При выполнении оператора continue происходит немедленный переход к следующей итерации цикла.
   Все инструкции после continue в текущей итерации пропускаются.
   Используется для пропуска выполнения части кода для определённых условий, сохраняя при этом продолжение работы цикла.
   Пример:
   `for (let i = 0; i < 10; i++) {
if (i % 2 === 0) {
continue; // Пропустить текущую итерацию, если i чётное
}
console.log(i); // Будут напечатаны только нечётные числа
}`
   Результат:
   1
   3
   5
   7
   9
   Ключевые отличия
   breakполностью завершает выполнение цикла.
   continue пропускает текущую итерацию, но цикл продолжается со следующей.
20. Что такое Generic
    Дженерики (или обобщения) - это параметризованные типы. 
    Обобщения в Java представляют собой механизм, позволяющий создавать классы, интерфейсы и методы, 
    которые могут работать с различными типами данных.
    Они позволяют писать код, который будет безопасным, типизированным и переиспользуемым.
    Основная идея обобщений заключается в том, чтобы параметризовать типы данных, используемые 
    в классе или методе, чтобы они могли работать с различными типами без необходимости повторного 
    написания кода для каждого типа.
    Примером использования обобщенных типов может служить Java Collection Framework.
    Так, класс LinkedList<E> - типичный обобщенный тип.
    Он содержит параметр E, который представляет тип элементов, которые будут храниться в коллекции.
    Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных.
    Вместо того, чтобы просто использовать LinkedList, ничего не говоря о типе элемента в списке, 
    предлагается использовать точное указание типа LinkedList<String>, LinkedList<Integer> и т.п.
    Документация: https://docs.oracle.com/javase/8/docs/technotes/guides/language/generics.html
21. Расскажите про такое зарезервированное слово как final, к чему
    применяется как используется.
Модификатор final:
Класс не может иметь наследников;
Метод не может быть переопределен в классах наследниках;
Поле не может изменить свое значение после инициализации;
Локальные переменные не могут быть изменены после присвоения им значения;
Параметры методов не могут изменять своё значение внутри метода.

https://github.com/Shell26/Java-Developer/blob/master/core.md#%D0%A7%D0%B5%D0%BC-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B0%D1%8E%D1%82%D1%81%D1%8F-final-finally-%D0%B8-finalize

22. Рассказать про Optional
